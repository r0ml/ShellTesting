
// Generated by Robert M. Lefkowitz <code@liberally.net> in 2025 using ChatGPT

// Subprocess.swift
// No Foundation

import Darwin

public final class RawProcess {
    public enum IO {
        case inherit
        case pipe
        case fileDescriptor(Int32) // pre-opened fd
    }

    public struct PipeEnds {
        public let readFD: Int32
        public let writeFD: Int32
    }

    public var executablePath: String
    public var arguments: [String] = []
    public var environment: [String: String]? = nil
    public var currentDirectory: String? = nil

    public var standardInput: IO = .inherit
    public var standardOutput: IO = .inherit
    public var standardError: IO = .inherit

    public private(set) var pid: pid_t = 0
    public private(set) var terminationStatus: Int32? = nil

    // If .pipe is selected, these are set after run()
    public private(set) var stdinPipe: PipeEnds? = nil       // parent writes to writeFD
    public private(set) var stdoutPipe: PipeEnds? = nil      // parent reads from readFD
    public private(set) var stderrPipe: PipeEnds? = nil      // parent reads from readFD

    public init(_ executablePath: String) {
        self.executablePath = executablePath
    }

    deinit {
        // Best effort: close any remaining FDs we own.
        func closeIfOpen(_ fd: Int32) {
            if fd >= 0 { _ = Darwin.close(fd) }
        }
        if let p = stdinPipe { closeIfOpen(p.readFD); closeIfOpen(p.writeFD) }
        if let p = stdoutPipe { closeIfOpen(p.readFD); closeIfOpen(p.writeFD) }
        if let p = stderrPipe { closeIfOpen(p.readFD); closeIfOpen(p.writeFD) }
    }

    // MARK: - Public API

    public func run() throws {
        guard pid == 0 else { return } // already running or ran

        // Build argv: [executablePath] + arguments
        let argvStrings = [executablePath] + arguments

        // Optional envp
        let envpStrings: [String]?
        if let environment {
            envpStrings = environment.map { "\($0.key)=\($0.value)" }
        } else {
            envpStrings = nil
        }

        // Create pipes if requested
        // For stdin pipe: parent writes -> child reads
        let stdinSetup = try setupPipeIfNeeded(standardInput, direction: .parentWritesChildReads)
        let stdoutSetup = try setupPipeIfNeeded(standardOutput, direction: .parentReadsChildWrites)
        let stderrSetup = try setupPipeIfNeeded(standardError, direction: .parentReadsChildWrites)

        // Save pipes for caller (parent side)
        self.stdinPipe = stdinSetup.parentSide
        self.stdoutPipe = stdoutSetup.parentSide
        self.stderrPipe = stderrSetup.parentSide

      var fileActions: posix_spawn_file_actions_t? = nil
      let irc = posix_spawn_file_actions_init(&fileActions)
      if irc != 0 { throw POSIXError(irc, "posix_spawn_file_actions_init") }
      defer { posix_spawn_file_actions_destroy(&fileActions) }

      posix_spawn_file_actions_init(&fileActions)
        defer { posix_spawn_file_actions_destroy(&fileActions) }

        // Wire up stdio
        try addStdioActions(&fileActions, stdio: STDIN_FILENO, io: standardInput, childFD: stdinSetup.childFD)
        try addStdioActions(&fileActions, stdio: STDOUT_FILENO, io: standardOutput, childFD: stdoutSetup.childFD)
        try addStdioActions(&fileActions, stdio: STDERR_FILENO, io: standardError, childFD: stderrSetup.childFD)

        // Optional cwd (Darwin extension)
        if let dir = currentDirectory {
            try dir.withCString { cstr in
                let rc = posix_spawn_file_actions_addchdir_np(&fileActions, cstr)
                if rc != 0 { throw POSIXError(rc, "posix_spawn_file_actions_addchdir_np") }
            }
        }

        // Spawn
        var child: pid_t = 0
        let rc: Int32 = try withCStringArray(argvStrings) { argv in
            if let envpStrings {
                return try withCStringArray(envpStrings) { envp in
                    // Cast envp to the type posix_spawn expects.
                    return posix_spawn(&child, executablePath, &fileActions, nil, argv, envp)
                }
            } else {
                // Inherit environment by passing environ
                return posix_spawn(&child, executablePath, &fileActions, nil, argv, environ)
            }
        }

        if rc != 0 {
            throw POSIXError(rc, "posix_spawn")
        }

        self.pid = child

        // Close child-side FDs in parent (we already dup2'd them in file actions)
        stdinSetup.closeChildSideInParent()
        stdoutSetup.closeChildSideInParent()
        stderrSetup.closeChildSideInParent()
    }

    @discardableResult
    public func wait() throws -> Int32 {
        guard pid != 0 else { return terminationStatus ?? 0 }
        var status: Int32 = 0
        while true {
            let w = Darwin.waitpid(pid, &status, 0)
            if w == -1 {
                if errno == EINTR { continue }
                throw POSIXError(errno, "waitpid")
            }
            break
        }


      @inline(__always) func wIfExited(_ s: Int32) -> Bool { (s & 0x7f) == 0 }
      @inline(__always) func wExitStatus(_ s: Int32) -> Int32 { (s >> 8) & 0xff }
      @inline(__always) func wIfSignaled(_ s: Int32) -> Bool { ((s & 0x7f) != 0) && ((s & 0x7f) != 0x7f) }
      @inline(__always) func wTermSig(_ s: Int32) -> Int32 { s & 0x7f }


        let code: Int32
        if wIfExited(status) {
            code = wExitStatus(status)
        } else if WIFSIGNALED(status) {
            code = 128 + wTermSig(status)
        } else {
            code = status
        }

        terminationStatus = code
        return code
    }

    public func terminate(signal: Int32 = SIGTERM) throws {
        guard pid != 0 else { return }
        if Darwin.kill(pid, signal) != 0 {
            throw POSIXError(errno, "kill")
        }
    }

    // MARK: - Helpers

    private enum PipeDirection {
        case parentWritesChildReads
        case parentReadsChildWrites
    }

    private struct PipeSetup {
        let parentSide: PipeEnds?
        let childFD: Int32?     // fd to be dup2'd onto stdio in child
        let childSideToCloseInParent: Int32?

        func closeChildSideInParent() {
            if let fd = childSideToCloseInParent {
                _ = Darwin.close(fd)
            }
        }
    }

    private func setupPipeIfNeeded(_ io: IO, direction: PipeDirection) throws -> PipeSetup {
        switch io {
        case .inherit:
            return PipeSetup(parentSide: nil, childFD: nil, childSideToCloseInParent: nil)
        case .fileDescriptor(let fd):
            return PipeSetup(parentSide: nil, childFD: fd, childSideToCloseInParent: nil)
        case .pipe:
            var fds: [Int32] = [-1, -1]
            if Darwin.pipe(&fds) != 0 {
                throw POSIXError(errno, "pipe")
            }
            // fds[0] = read, fds[1] = write
            switch direction {
            case .parentWritesChildReads:
                // child gets read end, parent keeps write end
                let parent = PipeEnds(readFD: -1, writeFD: fds[1])
                return PipeSetup(
                    parentSide: parent,
                    childFD: fds[0],
                    childSideToCloseInParent: fds[0] // parent must close child's read end
                )
            case .parentReadsChildWrites:
                // child gets write end, parent keeps read end
                let parent = PipeEnds(readFD: fds[0], writeFD: -1)
                return PipeSetup(
                    parentSide: parent,
                    childFD: fds[1],
                    childSideToCloseInParent: fds[1] // parent must close child's write end
                )
            }
        }
    }

    private func addStdioActions(
        _ actions: inout posix_spawn_file_actions_t?,
        stdio: Int32,
        io: IO,
        childFD: Int32?
    ) throws {
        switch io {
        case .inherit:
            // do nothing
            return
        case .fileDescriptor:
            guard let childFD else { return }
            let rc = posix_spawn_file_actions_adddup2(&actions, childFD, stdio)
            if rc != 0 { throw POSIXError(rc, "posix_spawn_file_actions_adddup2") }
            // Close the original after dup2 in child
            let rc2 = posix_spawn_file_actions_addclose(&actions, childFD)
            if rc2 != 0 { throw POSIXError(rc2, "posix_spawn_file_actions_addclose") }
        case .pipe:
            guard let childFD else { return }
            let rc = posix_spawn_file_actions_adddup2(&actions, childFD, stdio)
            if rc != 0 { throw POSIXError(rc, "posix_spawn_file_actions_adddup2") }
            let rc2 = posix_spawn_file_actions_addclose(&actions, childFD)
            if rc2 != 0 { throw POSIXError(rc2, "posix_spawn_file_actions_addclose") }
        }
    }
}

// MARK: - POSIXError + CString helpers (no Foundation)

public struct POSIXError: Error, CustomStringConvertible {
    public let code: Int32
    public let function: String

    public init(_ code: Int32, _ function: String) {
        self.code = code
        self.function = function
    }

    public var description: String {
        // strerror is POSIX; returns a C string
        let msg = String(cString: strerror(code))
        return "\(function) failed: \(code) (\(msg))"
    }
}

/// Create a null-terminated C string vector (`char **`) from `[String]`.
/// Memory is allocated and freed within the call.
private func withCStringArray<R>(_ strings: [String], _ body: ([UnsafeMutablePointer<CChar>?]) throws -> R) throws -> R {
    var cStrings: [UnsafeMutablePointer<CChar>?] = []
    cStrings.reserveCapacity(strings.count + 1)

    for s in strings {
        let dup = strdup(s)
        cStrings.append(dup)
    }
    cStrings.append(nil)

    defer {
        for p in cStrings where p != nil {
            free(p)
        }
    }

    return try body(cStrings)
}


/* example usage:

 var p = Subprocess("/bin/echo")
 p.arguments = ["hello", "world"]
 p.standardOutput = .pipe

 try p.run()

 if let out = p.stdoutPipe {
     var buf = [UInt8](repeating: 0, count: 4096)
     let n = read(out.readFD, &buf, buf.count)
     if n > 0 {
         let s = String(decoding: buf[0..<n], as: UTF8.self)
         print("child said:", s)
     }
 }

 let status = try p.wait()
 print("exit:", status)

 */
