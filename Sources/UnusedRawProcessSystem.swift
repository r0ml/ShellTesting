
// Generated by Robert M. Lefkowitz <code@liberally.net> in 2025 using ChatGPT

import Darwin
import SystemPackage

public final class Subprocess {
    public enum IO {
        case inherit
        case pipe
        case fileDescriptor(FileDescriptor)
    }

    public struct Pipe {
        // For stdin: parent writes
        // For stdout/stderr: parent reads
        public let readEnd: FileDescriptor?
        public let writeEnd: FileDescriptor?
    }

    public var executablePath: String
    public var arguments: [String] = []
    public var environment: [String: String]? = nil
    public var currentDirectory: FilePath? = nil

    public var standardInput: IO = .inherit
    public var standardOutput: IO = .inherit
    public var standardError: IO = .inherit

    public private(set) var pid: pid_t = 0
    public private(set) var terminationStatus: Int32? = nil

    public private(set) var stdinPipe: Pipe? = nil
    public private(set) var stdoutPipe: Pipe? = nil
    public private(set) var stderrPipe: Pipe? = nil

    public init(_ executablePath: String) {
        self.executablePath = executablePath
    }

    deinit {
        // Best effort cleanup: close any fds we own.
        try? stdinPipe?.readEnd?.close()
        try? stdinPipe?.writeEnd?.close()
        try? stdoutPipe?.readEnd?.close()
        try? stdoutPipe?.writeEnd?.close()
        try? stderrPipe?.readEnd?.close()
        try? stderrPipe?.writeEnd?.close()
    }

    // MARK: - Public API

    public func run() throws {
        guard pid == 0 else { return }

        let argvStrings = [executablePath] + arguments
        let envpStrings: [String]?
        if let environment {
            envpStrings = environment.map { "\($0.key)=\($0.value)" }
        } else {
            envpStrings = nil
        }

        // Create pipes if requested
        let stdinSetup  = try setupPipeIfNeeded(standardInput,  direction: .parentWritesChildReads)
        let stdoutSetup = try setupPipeIfNeeded(standardOutput, direction: .parentReadsChildWrites)
        let stderrSetup = try setupPipeIfNeeded(standardError,  direction: .parentReadsChildWrites)

        self.stdinPipe  = stdinSetup.parentPipe
        self.stdoutPipe = stdoutSetup.parentPipe
        self.stderrPipe = stderrSetup.parentPipe

        // posix_spawn file actions are optional-opaque on Darwin in Swift
        var actions: posix_spawn_file_actions_t? = nil
        let irc = posix_spawn_file_actions_init(&actions)
        if irc != 0 { throw POSIXSpawnError(irc, "posix_spawn_file_actions_init") }
        defer { posix_spawn_file_actions_destroy(&actions) }

        // Wire up stdio
        try addStdioActions(&actions, stdio: STDIN_FILENO,  io: standardInput,  childFD: stdinSetup.childFD)
        try addStdioActions(&actions, stdio: STDOUT_FILENO, io: standardOutput, childFD: stdoutSetup.childFD)
        try addStdioActions(&actions, stdio: STDERR_FILENO, io: standardError, childFD: stderrSetup.childFD)

        // Optional cwd (Darwin extension)
        if let cwd = currentDirectory {
            let rc = cwd.withPlatformString {
                posix_spawn_file_actions_addchdir_np(&actions, $0)
            }
            if rc != 0 { throw POSIXSpawnError(rc, "posix_spawn_file_actions_addchdir_np") }
        }

        // Spawn
        var child: pid_t = 0
        let rc: Int32 = try withCStringArray(argvStrings) { argv in
          try withUnsafePointer(to: actions) { actionsPtr in
            if let envpStrings {
              return try withCStringArray(envpStrings) { envp in
                return posix_spawn(&child, executablePath, actionsPtr, nil, argv, envp)
              }
            } else {
              return posix_spawn(&child, executablePath, actionsPtr, nil, argv, environ)
            }
          }
        }

        if rc != 0 { throw POSIXSpawnError(rc, "posix_spawn") }
        self.pid = child

        // Close child-side pipe ends in parent
        try stdinSetup.closeChildSideInParent()
        try stdoutSetup.closeChildSideInParent()
        try stderrSetup.closeChildSideInParent()
    }

    @discardableResult
    public func wait() throws -> Int32 {
        guard pid != 0 else { return terminationStatus ?? 0 }

        var status: Int32 = 0
        while true {
            let w = Darwin.waitpid(pid, &status, 0)
            if w == -1 {
                if errno == EINTR { continue }
                throw POSIXSpawnError(errno, "waitpid")
            }
            break
        }

        let code: Int32
        if wIfExited(status) {
            code = wExitStatus(status)
        } else if wIfSignaled(status) {
            code = 128 + wTermSig(status)
        } else {
            code = status
        }

        terminationStatus = code
        return code
    }

    public func terminate(signal: Int32 = SIGTERM) throws {
        guard pid != 0 else { return }
        if Darwin.kill(pid, signal) != 0 {
            throw POSIXSpawnError(errno, "kill")
        }
    }

    // MARK: - Internals

    private enum PipeDirection {
        case parentWritesChildReads
        case parentReadsChildWrites
    }

    private struct PipeSetup {
        let parentPipe: Pipe?
        let childFD: Int32?
        let childSideToCloseInParent: FileDescriptor?

        func closeChildSideInParent() throws {
            if let fd = childSideToCloseInParent {
                try fd.close()
            }
        }
    }

    private func setupPipeIfNeeded(_ io: IO, direction: PipeDirection) throws -> PipeSetup {
        switch io {
        case .inherit:
            return PipeSetup(parentPipe: nil, childFD: nil, childSideToCloseInParent: nil)

        case .fileDescriptor(let fd):
            return PipeSetup(parentPipe: nil, childFD: fd.rawValue, childSideToCloseInParent: nil)

        case .pipe:
            // Swift System: pipe() returns (readEnd, writeEnd)
            let (r, w) = try FileDescriptor.pipe()

            switch direction {
            case .parentWritesChildReads:
                // child reads from r; parent writes to w
                return PipeSetup(
                    parentPipe: Pipe(readEnd: nil, writeEnd: w),
                    childFD: r.rawValue,
                    childSideToCloseInParent: r
                )

            case .parentReadsChildWrites:
                // child writes to w; parent reads from r
                return PipeSetup(
                    parentPipe: Pipe(readEnd: r, writeEnd: nil),
                    childFD: w.rawValue,
                    childSideToCloseInParent: w
                )
            }
        }
    }

    private func addStdioActions(
        _ actions: inout posix_spawn_file_actions_t?,
        stdio: Int32,
        io: IO,
        childFD: Int32?
    ) throws {
        switch io {
        case .inherit:
            return

        case .fileDescriptor, .pipe:
            guard let childFD else { return }

            let rc = posix_spawn_file_actions_adddup2(&actions, childFD, stdio)
            if rc != 0 { throw POSIXSpawnError(rc, "posix_spawn_file_actions_adddup2") }

            let rc2 = posix_spawn_file_actions_addclose(&actions, childFD)
            if rc2 != 0 { throw POSIXSpawnError(rc2, "posix_spawn_file_actions_addclose") }
        }
    }
}

// MARK: - Wait-status helpers (macros not reliably imported)

@inline(__always) private func wIfExited(_ s: Int32) -> Bool { (s & 0x7f) == 0 }
@inline(__always) private func wExitStatus(_ s: Int32) -> Int32 { (s >> 8) & 0xff }
@inline(__always) private func wIfSignaled(_ s: Int32) -> Bool { ((s & 0x7f) != 0) && ((s & 0x7f) != 0x7f) }
@inline(__always) private func wTermSig(_ s: Int32) -> Int32 { s & 0x7f }

// MARK: - Error + CString helpers (no Foundation)

/*
public struct POSIXSpawnError: Error, CustomStringConvertible {
    public let code: Int32
    public let function: String

    public init(_ code: Int32, _ function: String) {
        self.code = code
        self.function = function
    }

    public var description: String {
        let msg = String(cString: strerror(code))
        return "\(function) failed: \(code) (\(msg))"
    }
}
*/


private func withCStringArray<R>(
    _ strings: [String],
    _ body: ([UnsafeMutablePointer<CChar>?]) throws -> R
) throws -> R {
    var cStrings: [UnsafeMutablePointer<CChar>?] = []
    cStrings.reserveCapacity(strings.count + 1)

    for s in strings {
        cStrings.append(strdup(s))
    }
    cStrings.append(nil)

    defer {
        for p in cStrings where p != nil { free(p) }
    }

    return try body(cStrings)
}

/* example usage :

 var p = Subprocess("/bin/echo")
 p.arguments = ["hello", "system"]
 p.standardOutput = .pipe

 try p.run()

 if let out = p.stdoutPipe?.readEnd {
     var buf = [UInt8](repeating: 0, count: 4096)
     let n = try out.read(into: &buf)
     if n > 0 {
         let s = String(decoding: buf[0..<n], as: UTF8.self)
         // prints "hello system\n"
         _ = write(STDOUT_FILENO, s, s.utf8.count) // or your own print
     }
 }

 _ = try p.wait()

 */
